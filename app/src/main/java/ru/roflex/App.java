/*
 * This source file was generated by the Gradle 'init' task
 */
package ru.roflex;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Set;
import java.util.stream.Collectors;

import com.fastcgi.FCGIInterface;

import java.math.BigDecimal;

public class App {
    private static final String HTTP_OK = """
            Status: 200 OK
            Content-Type: application/json
            Content-Length: %d
            
            %s
            """;

    private static final String HTTP_BAD_REQUEST = """
            Status: 400 Bad Request
            Content-Type: application/json
            Content-Length: %d
            
            {"reason": "%s"}
            """;

    private static final String ONE_SET_RESULT = """
            {
                "X": %.2f,
                "Y": %s,
                "R": %d,
                "hit": %b
            }
            """;

    private static final String RESULTS_WRAPPER = """
            {
                "results": [
                    %s
                ],
                "processing_time_ms": %s,
                "current_time": "%s"
            }
            """;

    private static final String NOT_ALLOWED = """
            Status: 405 Method Not Allowed
            Allow: POST
            Content-Type: application/json
            Content-Length: %d
            
            {"reason": "Only POST method is allowed"}
            """;

    public static void main(String[] args) throws IOException { // Floats should be either with dot or comma on client, but converted before sending
        FCGIInterface fcgiInterface = new FCGIInterface();
        while (fcgiInterface.FCGIaccept() >= 0) {

            StringBuilder stringBuilder = new StringBuilder();
            int c;
            while ((c = FCGIInterface.request.inStream.read()) != -1) {
                stringBuilder.append((char) c);
            }
            String body = stringBuilder.toString();

            String method = System.getenv("REQUEST_METHOD");
            if (method == null) {
                method = "GET"; // по умолчанию
            }

            if (!"POST".equalsIgnoreCase(method)) {
                String response = String.format(
                        NOT_ALLOWED,
                        "{\"reason\": \"Only POST method is allowed\"}".getBytes(StandardCharsets.UTF_8).length
                );
                System.out.println(response);
                continue;
            }

            var startTime = Instant.now();

            try {
                Params params = new Params(body);
                BigDecimal Y = params.getY();
                Set<Integer> R = params.getR();
                float X = params.getX();

                String results = R.stream()
                        .map(r -> {
                            boolean isHit = checkHit(X, Y, r);
                            return String.format(ONE_SET_RESULT, X, "\"" + Y.toPlainString() + "\"", r, isHit);
                        })
                        .collect(Collectors.joining(","));
                String currentTime = java.time.LocalTime.now().format(java.time.format.DateTimeFormatter.ofPattern("HH:mm:ss"));
                String responseContent = String.format(RESULTS_WRAPPER, results, Instant.now().toEpochMilli() - startTime.toEpochMilli(), currentTime);
                String response = String.format(HTTP_OK, responseContent.getBytes(StandardCharsets.UTF_8).length, responseContent);
                System.out.println(response);


            } catch (ParamsException e) {
                String response = String.format(HTTP_BAD_REQUEST, ("{\"reason\": \"" + e.getMessage() + "\"}").getBytes(StandardCharsets.UTF_8).length, e.getMessage());
                System.out.println(response);
            }
        }
    }

    private static boolean checkHit(float _X, BigDecimal Y, Integer _R) {
        BigDecimal X = new BigDecimal(_X);
        BigDecimal R = new BigDecimal(_R);
        BigDecimal nul = new BigDecimal(0);
        BigDecimal two = new BigDecimal(2);

        if (Y.compareTo(nul) < 0 && X.compareTo(nul) < 0) return false;
        if (Y.compareTo(nul) > 0 && X.compareTo(nul) > 0)
            return X.multiply(X).add(Y.multiply(Y)).compareTo((R.divide(two)).multiply(R.divide(two))) <= 0;
        if (Y.compareTo(nul) > 0 && X.compareTo(nul) < 0) return X.negate().compareTo(R) <= 0 && Y.compareTo(R) <= 0;
        if (Y.compareTo(nul) < 0 && X.compareTo(nul) > 0)
            return Y.compareTo(X.divide(two).add(R.divide(two).negate())) >= 0;
        if (Y.equals(nul)) return X.compareTo(R.negate()) >= 0 && X.compareTo(R) <= 0;
        return Y.compareTo(R.divide(two).negate()) >= 0 && Y.compareTo(R) <= 0;
    }
}

